<?php

namespace AppBundle\Entity\Repository;

use Doctrine\ORM\EntityRepository;

/**
 * IssuesRepository
 *
 * This class was generated by the PhpStorm "Php Annotations" Plugin. Add your own custom
 * repository methods below.
 */
class IssuesRepository extends EntityRepository
{
    public function aColumns($get, $alias, $aliasJoin)
    {
        $aColumns = array();
        foreach ($get['columns'] as $value) {
            if (strlen($value['name']) > 0) {
                if ($value['name'] == 'nombreCategoria') {
                    $aColumns[] = $aliasJoin . '.' . $value['name'];
                } else {
                    $aColumns[] = $alias . '.' . $value['name'];
                }
            }
        }

        return $aColumns;
    }

    /**
     * @param array $get
     * @param bool $flag
     *
     * @return array|\Doctrine\ORM\Query
     */
    public function ajaxTable(array $get, $flag = false)
    {

        $qb = $this->createQueryBuilder('issue')
            ->select('issue.id as id, issue.title  as title, issue.description as description, issueType.name as issue_type_name , issueStatus.name as issue_status_name, issueStatus.colour as issue_status_colour')
            ->leftJoin('issue.issueType', 'issueType')
            ->leftJoin('issue.issueStatus', 'issueStatus');

        if (isset($get['search']) && $get['search'] != '') {
            $search = $get['search']['value'];
        } else {
            $search = false;
        }

        if ($search) {
            $qb->andWhere(
                $qb->expr()->orX(
                    $qb->expr()->like('issue.title', ':search'),
                    $qb->expr()->like('issue.description', ':search'),
                    $qb->expr()->like('issueType.name', ':search'),
                    $qb->expr()->like('issueStatus.name', ':search')
                ))->setParameter('search', '%' . $search . '%');
        }

        //aqui se establece el campo de ordenación
        if (isset($get['order'])) {
            //obtiene la columna a ordenar
            $searchCol= $get['columns'][   $get['order'][0]['column']   ] ;
            if ( $searchCol['orderable'] == 'true') {
                $qb->orderBy($searchCol['name'], $get['order'][0]['dir']);
            }
        }

        //aqui se establecen los limites de la paginación
        if (isset($get['start']) && $get['length'] != '-1') {
            $qb->setFirstResult((int)$get['start'])
                ->setMaxResults((int)$get['length']);
        }

        $query = $qb->getQuery();
        if ($flag) {
            return $query;
        } else {
            return $query->getResult();
        }
    }

    /**
     * Devuelve la catidad de registros filtrados
     *
     * @param array $get
     *
     * @return array|\Doctrine\ORM\Query
     */
    public function getFilteredCount(array $get)
    {

        $qb = $this->createQueryBuilder('issue')
            ->select('count(issue.id)');

        if (isset($get['search']) && $get['search'] != '') {
            $search = $get['search']['value'];
        } else {
            $search = false;
        }

        if ($search) {
            $qb->andWhere(
                $qb->expr()->orX(
                    $qb->expr()->like('issue.title', ':search'),
                    $qb->expr()->like('issue.description', ':search')
                ))->setParameter('search', '%' . $search . '%');
        }

        return $qb->getQuery()->getSingleScalarResult();

    }

    /**
     * @return int
     */
    public function getCount()
    {
        $aResultTotal = $this->getEntityManager()
            ->createQuery('SELECT COUNT(i) FROM AppBundle:Issues i')
            ->setMaxResults(1)
            ->getResult();

        return $aResultTotal[0][1];
    }















    public function getFiltering($cb, $get, $aColumns)
    {
        if (isset($get['search']) && $get['search'] != '') {
            $aLike = array();
            for ($i = 0; $i < count($aColumns); $i++) {
                if (isset($get['columns'][$i]) && $get['columns'][$i]['searchable'] == "true") {
                    $aLike[] = $cb->expr()->like($aColumns[$i], '\'%' . $get['search']['value'] . '%\'');
                }
            }
            if (count($aLike) > 0) {
                $cb->andWhere(new Expr\Orx($aLike));
            } else {
                unset($aLike);
            }
        }
    }

}
